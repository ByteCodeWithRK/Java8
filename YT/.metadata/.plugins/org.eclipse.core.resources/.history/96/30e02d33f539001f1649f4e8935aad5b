package com.java8.functional;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import com.java8.DataSource;
import com.java8.Players;

public class FunctionalInterfaceEx {

	public static void main(String[] args) {
		
		
		// Single abstract method and can have any no.of static or default 
		// java.util.function package
		// Runnable, Callable, Comparable, Comparator, ActionListner, etc.,
	
		//After Java8:
		//1. Consumer 
		// Accepts Single parameter and doesn't return anything
		//EX1
		//1.accept()
		//consumerWithAbstractMethods();
		//2.andThen(). i.e., f1.andThen(f2);
		//consumerWithDefaultMethods();
		//consumerWithCustomObject();	
	
		
	/*
		//2. Supplier  
		// Doesn't accept params but returns values
		//Ex1
		Supplier<String> s = () ->{
			return "Welcome to BytecodeWithRK";
		};
		System.out.println(s.get());
		
		//Ex2
		Supplier<Integer> s1 = () ->{
			return 100;
		};
		System.out.println(s1.get());
		
		Supplier<Map<Integer, Players>> players =() ->{
			return DataSource.getData().stream()
					.collect(Collectors.toMap(e ->e.getNumber(), p ->p));
		};
		System.out.print("\n"+players.get()+"\n");

	*/
		
		
	/*
		//3. Predicate
		// Which accepts single param and returns boolean value
		// Evaluate the condition(input) and returns boolean
		//Ex1
		predicateWithTestMethod();
		predicateWithDefaultMethods();
		predicateWithStaticMethods();
		predicateWithCustomObjectTypes();
	
	*/
		
		

		
	/*4. Function
	 * It's an functional interface from java8
	 * Def:	It takes single input parameter and return single value.
	*/
	//Function functional interface having different methods in it

	//1. apply();
	functionWithAbstractMethod();
	functionWithDefaultMethods();
	functionWithStaticMethods();
	functionWithCustomObjects();//Custom object
		
		
	}
	public static void functionWithAbstractMethod() {
		Function<String, Integer> fun = (param1) -> { return param1.length();};
		System.out.println("Function::Abstract::Apply::"+fun.apply("ByteCodeWithRK"));
	
	}
	
	public static void functionWithDefaultMethods() {
		//2. andThen() ii.e., f1.andThen(f2)
				Function<Integer, Integer> test = (param1) ->{
					return param1 * param1;
				};
				//test.apply(2); //4
				Function<Integer, Integer> test1 = (param1) ->{
					return param1 +10;
				};
				System.out.println("Function::default::andThen::"+test.andThen(test1).apply(7)); //59

				//3. compose()
				//f2.compose(f1). i.e., f1 followed by f2 will be executed.
				System.out.println("Function::default::Compose::"
							+test.compose(test1).apply(4)); //
				
	}
	
	public static void functionWithStaticMethods() {
		//4. Identity()
				//Takes whatever input return the same value
				Function<Integer, Integer> identity = Function.identity();
				System.out.println("Function::Static::Identity::"+identity.apply(8));
				
	}
	
	
	public static void functionWithCustomObjects() {
		Function<List<Players>, List<String>> custom =(param1) ->{
			 return param1.stream().map(e -> e.getName())
				//.filter(s ->s.contains("MS Dhoni"))
				.collect(Collectors.toList());
			};
			System.out.println("Function::Custom::"+
			custom.apply(DataSource.getData()));
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
/*
    
	private static void consumerWithDefaultMethods() {
		Consumer<String> c1 = (param1)->{
			System.out.println("Consumer::Default::andThen::c1::"+param1+" Welcomes you");
		};
		Consumer<String> c2 = (param1)->{
			System.out.println("Consumer::Default::andThen::c2::"+param1.toLowerCase());
		};
		c1.andThen(c2).accept("BYTECODEWITHRK");
	}



	public static void consumerWithCustomObject() {
		Consumer<List<Players>> listPlayers =(param1)->{
			param1.stream().forEach(System.out::println);
		};
		listPlayers.accept(DataSource.getData());;
	}
	
	public static void consumerWithAbstractMethods() {
		Consumer<String> consumer =(param1) -> {
			System.out.println("Consumer::Abstract::accept::"+param1.toLowerCase());
		};
		consumer.accept("WELCOME TO BYTECODEWITHRK");
	    //Ex2
		Consumer<Integer> consumer1 =(param1) -> {
			System.out.println("Consumer::Custom Object::"+(param1* param1));
		};
		consumer1.accept(10);
	}
	
	public static void predicateWithCustomObjectTypes() {
		System.out.println("Predicate::Custom Object::");
		DataSource.getData().stream().map(e -> e.getName())
		.filter(s ->s.contains("Virat Kohli"))
		.forEach(System.out::print);;

		
	}
	private static void predicateWithStaticMethods() {
		//isEqual()
		//Compares the input param with actual
		Predicate<Integer> p = Predicate.isEqual(10);
		System.out.println("Predicate::Static::isEqual()"
				+p.test(20));
		
		//not
		//Negate the returned predicate value
		System.out.println("Predicate::Static::not()"
				+Predicate.not(p).test(20));
		
	}

	private static void predicateWithDefaultMethods() {
		//and()
		//If both predicates returns true then result is true else false
		Predicate<String> p =(param1) ->{
			boolean b = param1.startsWith("S");
			return b;
		};
		Predicate<String> p1 =(param1) ->{
			boolean b = param1.startsWith("J");
			return b;
		};
		System.out.println("Predicate::Default::and()::"
				+p.and(p1).test("Java"));
		
		//or()
		// Either one of the predicate is true then it is true else false
		
		System.out.println("Predicate::Default::or()::"
				+p.or(p1).test("Java"));
		
		//negate()
		//It will reverse the boolean value of predicate
		System.out.println("Predicate::Default::negate()::"
				+p1.negate().test("Java"));
		
	}

	private static void predicateWithTestMethod() {
		Predicate<String> string = (param1) ->{
			return param1.startsWith("W");
		};
		;
		System.out.println("Predicate::Abstract::test(String)::"
					+string.test("Java"));
		
		Predicate<Integer> integer = (param1) ->{
			return param1 > 18;
		};
		;
		System.out.println("Predicate::Abstract::test(Integer)::"
					+integer.test(200));
	}
*/
}

